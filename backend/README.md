# Concord back-end
## Starting
**For development:** install all dependencies with the command. _In this case we will use SQLite as our database_.
```
npm install
```

**For production:** first install the Node.js client of your SQL database and then run
```
npm install --production
```

## Before running the project
Create a .env file with the following
```
NODE_ENV=
PORT=
JWT_SECRET=
DB_DIALECT=
DB_NAME=
DB_USER=
DB_PASSWORD=
DB_HOST=
```

Variables:
*   `NODE_ENV`: environment of execution of the server. 
*   `PORT`: port where the server is going to listen.
*   `JWT_SECRET`: secret to sign the JWTs. It can be any string, but in production it must be a secure string and extremely difficult to guess.
*   `DB_DIALECT`: `mysql` | `postgres` | `sqlite` | `mariadb` | `mssql` | `db2` | `snowflake` | `oracle`.
*   `DB_USER`: database user to be connected.
*   `DB_PASSWORD`: DB user password.
*   `DB_HOST`: host of the DB.

In **development** you just need to set the `PORT` and `JWT_SECRET` variables.

In **production** you need to set the `NODE_ENV` variable to `production` and the rest of the variables accordingly.


## Running the project
In development use the command
```
npm run dev
```

In production use the command
```
npm start
```

### Arguments
* Mode: `<command> --mode=<development | testing | production>`
  
## Contributing
**Read the CONTRIBUTING.md file first, this is an extension of that file.**

Contributions are open for code development and maintenance. You are also welcome to write tests to verify the stability of the application, including where the application is tested in extreme cases (traffic stress tests are not allowed at the moment).

### Modules
Module handling will be done through CommonJS and there is no expected transition to ECMAScript modules in the near future.

### Directories
*   **api**: the different routes and middlewares of the application are defined and the models are added to handle the requests.

*   **models**: it is the representation of the information with which the system operates, therefore it manages all accesses to such information, both queries and updates. The requests for access or manipulation of information reach the 'model' through the 'controller'. Here the models are mainly defined using Sequelize ORM.

*   **controllers**: this is where the business logic is implemented. In this application the response of the controller does not render a view, instead it responds with information (JSON, status codes, plain text, etc.) to be used by the client.

*   **db**: it is the general configuration of the database using Sequelize, in general it is recommended not to edit the files in this directory.

*   **test**: different files constitute the different tests of the application.

*   **utils**: small utilities that can potentially be reused in the application.

*   **public**: files that can be publicly accessed by the client, probably in this directory will be placed all the files generated by React.js except index.html.

### Methodology
All contributions or changes to the code must be accompanied by unit tests to _test_ that change in order to ensure, to a certain extent, that everything continues to work properly. _The test framework to be used is Mocha + Chai_ .

### Recommendations
Each code file should be dedicated to doing a specific task. It could be conceived, where appropriate, that different subdirectories with code files are modules, and therefore it is considered good practice that each module be loosely coupled and have strong cohesion in their components. 

For convenience purposes, different exports that relate to a logical and functional domain could be grouped into a single 'index.js' file that re-exports them. For example, suppose that in the 'models' directory there are several files such as 'cow.js', 'dog.js' and 'eagle.js' where each one exports its corresponding model. Since all the files represent animal models, an 'index.js' file can be created within the same directory that gathers and re-exports all the models like this:
```javascript
const cow = require('./cow.js');
const dog = require('./dog.js');
const eagle = require('./eagle.js');

module.exports = { cog, dog, eagle } // this
```
Now from a single file several models can be imported at convenience, in the following example only two selected models will be imported using [destructuring](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment):
```javascript
// I just need dog and cow from the folder 'models'
const { dog, cow } = require('../models/index.js');
```
